# Home

<div class="grid cards" markdown>

- :simple-git: **[Git](./tools/git/intro.md)**

- :airplane_small: **[Career](./career/roadmap/developer-plan.md)**

- :simple-tmux: **[tmux](./tools/terminal/tmux/tmux.md)**

- :octicons-video-24: **[Video](./video/vid.md)**

- :material-text-search: **[Research](./research/ai.md)**

</div>

---

## Skills vs Knowledge

!!! success "Skills vs Knowledge"

    > Knowledge

    An effective way to think about **knowledge** is that it is ==a collection of memories== that are **disconnected** from each other.

    > Skills

    Have you ever heard the popular saying that goes like this:

    once you learn how to ride a bicycle, you never forget? This is **because** ==riding a bicycle== is not knowledge; **it’s a skill**. An effective way to think about skills is that they are collections of memories that are **connected** to each other.

    The most important thing about skills for you to keep in mind is that although you can acquire knowledge by reading or listening, ==you can only develop skills== **by doing**.

---

!!! quote "In Nepali"

In Nepali, the terms "knowledge" and "skills" are translated as:

1.  **Knowledge** – "ज्ञान" (Gyaan)

    - Refers to the understanding, information, or awareness gained through experience or education. It is the theoretical aspect of learning and refers to what one knows.

2.  **Skills** – "कौशल" (Kaushal)

    - Refers to the practical ability or expertise to perform tasks or activities effectively. Skills are acquired through practice and experience and are more action-oriented.

In summary:

- ज्ञान (Gyaan) is about what you know (theoretical knowledge).
- कौशल (Kaushal) is about what you can do (practical ability).

---

## Which is improtant

!!! tip "which is more important"

Both knowledge and skills are important, but their significance often depends on the context. Here’s a breakdown:

1.  **Knowledge** (ज्ञान) is important because it provides the foundation. It helps you understand concepts, theories, and the "why" behind things. It allows you to make informed decisions, think critically, and understand the bigger picture.

2.  **Skills** (कौशल) are crucial because they allow you to take action. Skills are what you use to apply your knowledge in real-life situations. They enable you to perform tasks, solve problems, and get things done.

In many cases, a combination of both is needed. For example:

- In a profession like medicine, **knowledge** about the human body is critical, ==but== **skills** like performing surgery or diagnosing illnesses are essential too.
- In a job like teaching, **knowledge** of the subject matter is important, ==but== **skills** like communication and classroom management are key to teaching effectively.

Ultimately, while knowledge can give you a solid theoretical understanding, skills allow you to turn that knowledge into action. Which do you think is more critical in your field or for your goals?

---

## In Programming

!!! question "Which is more important in programming?"

In programming, both **knowledge** and **skills** are incredibly important, ==but **skills** tend to have a slight edge in terms of day-to-day effectiveness==. Here's why:

???+ quote "Knowledge in Programming (ज्ञान)"

    - **Understanding Concepts**: Knowledge of algorithms, data structures, design patterns, programming languages, and best practices is essential to writing efficient, maintainable, and scalable code. Without the foundational knowledge, it’s hard to make informed decisions about how to approach problems.
    - **Problem-Solving**: Knowledge helps you understand the theory behind how and why certain approaches work. For example, knowing how sorting algorithms work can help you choose the right one for your problem.

???+ quote "Skills in Programming (कौशल)"

    - **Hands-on Practice**: The ability to actually write code, debug it, and optimize it is what makes you an effective programmer. Skills like writing clean, readable code, debugging issues, using version control systems, and working with frameworks are learned through practice and experience.
    - **Problem-Solving in Real Time**: While knowledge helps you understand the "why," programming skills allow you to apply that knowledge effectively. The more you practice, the quicker and better you'll be at translating your knowledge into solutions.

???+ quote "Why Skills Are Slightly More Important:"

    - In programming, you often encounter problems that require quick solutions. The ability to write code, troubleshoot bugs, and implement efficient solutions directly impacts your productivity.
    - Experience (a key component of skill) helps you handle new challenges by relying on your intuition and past experiences.

However, knowledge is ==critical== for long-term growth. As you continue programming, your deep understanding of how things work (like memory management, performance trade-offs, or new programming paradigms) will shape your ability to tackle increasingly complex challenges.

???+ success "Conclusion"

    - **Skills** are essential for ==getting things done==, and they improve through practice and hands-on experience.
    - **Knowledge** is necessary to ==solve problems intelligently== and to grow as a developer.

    ==For most people==, building **skills** will take precedence at the start, but investing in **knowledge** over time is key to long-term success and mastery in programming.

---

## Learning MERN STACK

!!! success "Learning MERN Stack"

Ah, you’re working with the MERN stack—that’s awesome! The MERN stack refers to a combination of technologies used to develop full-stack web applications. It includes:

- MongoDB (database)
- Express.js (backend framework)
- React.js (frontend library)
- Node.js (runtime environment)

In the context of **MERN**, both **knowledge** and **skills** are highly relevant, but let’s dive into how each plays a role in mastering the stack.

???+ quote "Knowledge in MERN Stack (ज्ञान)"

    - **Understanding of Each Component**: Knowing how MongoDB works (NoSQL database), how Express and Node interact (backend/server-side), and how React manages the user interface (UI) on the frontend is crucial. You need a solid grasp of how these components communicate with each other.

    - **Programming Concepts**: Knowledge of JavaScript, asynchronous programming (Promises, async/await), HTTP methods (GET, POST, etc.), REST APIs, and basic database operations is fundamental to developing a MERN application.

    - **Design Patterns**: Understanding common patterns, like MVC (Model-View-Controller) for structuring your app, or the component-based architecture of React, is valuable. Knowing when and how to apply these patterns will improve the quality and maintainability of your code.

???+ quote "Skills in MERN Stack (कौशल)"

    - **Writing Code**: The ability to implement routes in Express, structure data models in MongoDB, manage state in React, and handle asynchronous data flows is essential. You’ll improve your skills by building real-world projects, writing reusable components in React, setting up authentication in Express, etc.

    - **Debugging and Problem-Solving**: The skill to troubleshoot issues—whether it's fixing an API call, dealing with a database query, or debugging React’s re-rendering issues—becomes more intuitive as you practice.

    - **DevOps and Deployment**: The skill of deploying your application (using services like Heroku, AWS, or Docker) and optimizing it for production is essential. This requires hands-on experience.

Which is More Important in MERN?

In the **MERN stack, skills** are key when you're building projects. You’ll need practical skills to create, test, and deploy your apps. However, the **knowledge** of the underlying technologies (like understanding React hooks, how MongoDB queries work, or how Node.js handles asynchronous tasks) will give you the ability to write efficient, scalable, and maintainable code.

In the beginning, focus on ==gaining skills== through small projects and practice, ==then deepen your== **knowledge** as you tackle more complex applications and optimizations.

---

## 80/20 Principle while Learning

Here's how you can integrate the 80/20 Principle (Pareto Principle) into your programming learning process along with the other strategies I mentioned earlier:

??? note "80/20 Principle (Pareto Principle)"

    -   **What it is**: The Pareto Principle suggests that roughly 80% of outcomes come from 20% of the efforts. In programming, this means that a small fraction of concepts or skills will provide the majority of the value in your work or learning process.

    -   **How to apply**: Identify the ==20% of skills or concepts== that will have the greatest impact on your programming success. For example:

              -   In a new programming language or framework, focus on mastering the most commonly used features, libraries, or patterns (such as understanding data structures in Python or core concepts in React).

              -   Instead of trying to learn everything about a new framework, ==focus on the most frequently used functionality== (e.g., mastering state management in React or mastering queries in SQL).

              -   Focus on problem-solving techniques or concepts that show up most in coding interviews or real-world applications (e.g., recursion, algorithms, APIs).

    -   **Benefit**: Saves time and resources by directing your efforts toward the most impactful and relevant areas. This allows you to ==be productive quickly== and ==solve practical problems== with minimal learning time.

??? example "Example of Applying the 80/20 Principle in Learning:"

    -   If you're learning **JavaScript**, instead of trying to understand every single detail of the language, you could ==focus on the== **20% of features** that will be the most useful across most projects:

          -   Functions, closures, and callbacks.
          -   Array methods (map, filter, reduce).
          -   Promises and async/await.
          -   Basic understanding of ES6 features (let/const, destructuring, spread/rest).

    -   Mastering just these concepts will likely allow you to work on most JavaScript projects effectively, covering **80% of what you’ll need** to know in most situations.

???+ quote "Combining It All:"

    -   **80/20 + The Feynman Technique**: Focus on the most critical concepts using the 80/20 rule, then teach those concepts using the Feynman Technique to ensure you truly understand them.

    -   **80/20 + Deliberate Practice**: Identify the core skills that will benefit you most and engage in deliberate practice by targeting these high-value areas.

    -   **80/20 + Pomodoro Technique**: Apply the 80/20 rule to narrow your focus, then break that down into Pomodoro sessions to stay productive and focused on the most critical learning.

    -   **80/20 + Spaced Repetition**: Focus your spaced repetition on the key programming concepts that offer the greatest value (according to the 80/20 rule) to retain them for the long term.

By combining the **80/20 Principle** with the other strategies, you can ensure that you’re focusing on the most important aspects of your learning while also making sure that you retain that knowledge and apply it effectively in real-world situations.

---

**80/20 + Spaced Repetition**

Absolutely! The combination of the 80/20 Principle and Spaced Repetition is a powerful strategy for long-term retention of the most critical programming concepts. Here's how you can approach it:

---

> Step 1: Identify the 20% of Concepts (80/20 Rule)

First, you need to identify which 20% of programming concepts are most essential to your growth or project success. These concepts should be those that appear frequently or are highly applicable across a variety of projects.

Let's break down some key programming concepts to focus on:

??? example "Example Programming Concepts (for a general programming context):"

    -   **Data Structures**: Arrays, Linked Lists, Stacks, Queues, Hash Tables, Trees, Graphs

    -   **Algorithms**: Sorting (QuickSort, MergeSort), Searching (Binary Search), Recursion, Dynamic Programming

    -   **Coding Patterns**: DRY (Don't Repeat Yourself), KISS (Keep It Simple, Stupid), MVC (Model-View-Controller)

    -   **Language-Specific Constructs**: Functions, Closures, Promises (JavaScript), Classes & Objects (OOP), Lambdas (Python, JavaScript)

    -   Frameworks**: React Hooks, State Management (Redux or Context API for React), REST APIs

    -   **Version Control**: Git basics (commit, push, pull, branches)

    -   **Database Queries**: SQL basics (SELECT, INSERT, JOIN)

> Step 2: Create a Spaced Repetition Schedule for These Key Concepts

Once you've identified these core concepts, you can structure your spaced repetition to ensure these are reviewed at increasing intervals. Here’s a basic framework for how spaced repetition works:

???+ tip "Spaced Repetition Intervals:"

    -   **Day 1**: Review the material the same day you learn it.

    -   **Day 2–3**: Review the material again within 2–3 days to reinforce your memory.

    -   **Day 7**: Review it after about a week.

    -   **Day 14**: Review it after about two weeks.

    -   **Day 30**: Review it after a month.

Tools for Spaced Repetition:

- Use apps like [Anki](#), [Quizlet](#), or [Memrise](#) to create digital flashcards and schedule your spaced repetition sessions.

- Alternatively, you could use a paper-based or digital notebook to mark the days when you need to revisit certain concepts.

---

> Step 3: Create Flashcards for Key Concepts

For the spaced repetition to work, you need questions/flashcards that focus on the most essential concepts identified by the 80/20 rule. Here are examples of flashcards for some of the concepts:

???+ tip "Flashcards for Core Programming Concepts:"

    **1.  Data Structures:**

    -   **Q**: What is the time complexity of inserting an element into a hash table?

    -   **A**: O(1) on average (with proper hashing and minimal collisions).

    **2  Algorithms:**

    -   **Q**: What is the difference between **MergeSort** and **QuickSort**?

    -   **A**: MergeSort is O(n log n) in all cases, while QuickSort has an average time complexity of O(n log n) but a worst-case time complexity of O(n²).

    **3.  JavaScript Concepts:**

    -   **Q**: What is a closure in JavaScript, and why is it useful?

    -   **A**: A closure is a function that remembers its lexical scope even when the function is executed outside that scope. It's useful for data encapsulation and private variables.

    **4.  React Concepts:**

    -   **Q**: How does the **useEffect** hook work in React?

    -   **A**: `useEffect` is used to perform side effects in function components. It runs after the render and can be used to fetch data, update the DOM, or subscribe to external events.

    **5.  Version Control (Git):**

    -   **Q**: What is the difference between **git merge** and **git rebase**?

    -   **A**: `git merge` combines two branches, keeping the history of both branches. `git rebase` rewrites the history by applying the changes from one branch onto another, creating a cleaner, linear history.

---

> Step 4: Use Spaced Repetition to Continuously Reinforce These Concepts

For each concept, set up a spaced repetition system that asks you to review key topics at the intervals I mentioned above.

For instance, if you’re using [Anki](#) (a popular tool for spaced repetition):

1.  **Create Flashcards**: Add flashcards with key questions about the most important programming concepts.

2.  **Review Regularly**: The app will show you these flashcards in intervals based on how well you’ve remembered them. Initially, you’ll review frequently, but as you remember them better, the app will increase the interval.

3.  **Focus on Weak Areas**: If you keep forgetting a particular concept (e.g., binary search algorithm), the spaced repetition tool will prioritize that concept until it sticks.

---

> Example of a Spaced Repetition Schedule Using Anki:

1.  **Day 1 (Learning)**: You learn about ==Binary Search==. Create flashcards:

    - **Q**: What is the time complexity of Binary Search?

    - **A**: O(log n) for sorted arrays.

2.  **Day 2 (First Review)**: You review Binary Search. You remember it well.

3.  **Day 7 (Second Review)**: You review it again a week later. You remember it but need a little prompting.

4.  **Day 14 (Third Review)**: Review again in two weeks. At this point, it should be well-memorized.

5.  **Day 30 (Fourth Review)**: Review it after a month. You’ll likely remember it without much effort.

---

> Combining 80/20 and Spaced Repetition in Practice:

By focusing on the ==20% of programming concepts== that will help you the most (according to the 80/20 rule), and reviewing them using spaced repetition, you’ll maximize your retention with ==minimal effort==. This approach ensures that the most important concepts stick with you long-term while avoiding wasted time on less impactful material.

## This strategy keeps your learning efficient, focused, and sustainable, ensuring that you retain only the most useful knowledge over time.

## Others

The 80/20 Principle (Pareto Principle) is a great starting point, but there are several other frameworks and strategies that can help optimize learning in programming or any new framework. Here are some alternatives you can consider:

### 1. The Feynman Technique

- **What it is**: Named after physicist Richard Feynman, this technique emphasizes teaching what you’ve learned in simple terms. If you can explain a concept to a beginner, you truly understand it.

- **How to apply**: After learning a concept, try explaining it to someone (or even yourself) as if they have no prior knowledge. If you get stuck or can’t explain it clearly, it’s a sign you need to revisit that concept.

- **Benefit**: Forces deeper understanding and can highlight gaps in your knowledge.

---

### 2. The Learning Pyramid

- **What it is**: This is a model that shows how we retain information. It suggests that the most effective learning happens when we actively engage with material (like teaching, practicing, or discussing it).

- **How to apply**: Start by actively building projects, solving problems, or collaborating with others. The more you interact with what you’re learning, the more effectively you retain it.

- **Benefit**: Encourages hands-on learning, which is often more effective than passive methods like reading or watching videos.

---

### 3. The Eisenhower Matrix (Urgent vs. Important)

- **What it is**: This matrix helps prioritize tasks based on urgency and importance.

- **How to apply**: Break down your programming learning goals or tasks into four categories:

      - ==Urgent and Important==: Bugs or urgent issues that need fixing.
      - ==Important, Not Urgent==: Long-term learning (e.g., mastering a framework).
      - ==Urgent, Not Important==: Interruptions or low-priority tasks (e.g., optimizing code that isn’t critical).
      - ==Not Urgent, Not Important==: Distractions (e.g., random exploration that isn’t aligned with your current goals).

- **Benefit**: Helps you focus on what will have the most significant impact on your learning progress.

---

### 4. Deliberate Practice

- **What it is**: A method of learning that emphasizes practicing specific skills in a targeted way to improve performance over time.

- **How to apply**: Identify areas in your programming skills that need improvement (e.g., debugging, understanding algorithms). Focus practice on these areas with feedback, and gradually increase difficulty.

- **Benefit**: Maximizes skill improvement by focusing on weaknesses and challenging yourself.

---

### 5. Pomodoro Technique

- **What it is**: A time management method where you break work into 25-minute intervals, separated by short breaks.

- **How to apply**: Work on programming tasks in 25-minute sessions (called "Pomodoros"), then take a 5-minute break. After four Pomodoros, take a longer break (15–30 minutes).

- **Benefit**: Prevents burnout, boosts focus, and encourages consistent progress.

---

### 6. Spaced Repetition

- **What it is**: A learning technique based on increasing intervals of review to help with long-term retention of information.

- **How to apply**: Use tools like Anki or other spaced repetition apps to review programming concepts, syntax, or patterns at increasing intervals to keep them fresh in your memory.

- **Benefit**: Helps you remember concepts for the long term by reviewing them at strategic intervals.

---

### 7. The "Just-In-Time" Learning Principle

- **What it is**: This principle suggests you only learn what you need at the moment you need it.

- **How to apply**: Rather than learning everything upfront, focus on learning concepts as you encounter challenges in your project or framework. This prevents information overload and keeps your learning directly relevant.

- **Benefit**: Allows you to apply knowledge immediately, increasing motivation and contextual understanding.

---

### 8. The 5 Whys

- **What it is**: A problem-solving technique used to explore the cause-and-effect relationships underlying a particular problem.

- **How to apply**: When you encounter an issue in your code or project, ask "Why?" five times to identify the root cause of the problem, not just the symptoms.

- **Benefit**: Helps you understand the deeper issues in your code or framework, leading to better debugging and problem-solving.

---

### 9. Microlearning

- **What it is**: A strategy that breaks down learning into small, digestible chunks that can be consumed in a short amount of time.

- **How to apply**: Instead of learning long stretches of material, focus on small, bite-sized lessons that you can complete in 10–20 minutes. Use resources like interactive coding platforms (e.g., freeCodeCamp, Exercism).

- **Benefit**: Makes learning less overwhelming and can be easily incorporated into daily life.

---

### 10. Rubric-based Learning

- **What it is**: Use predefined criteria or rubrics to track your progress and evaluate your work.

- **How to apply**: Create a rubric for a specific programming skill or project, listing different levels of proficiency and key concepts. Assess yourself regularly against the rubric and work toward advancing to the next level.

- **Benefit**: Provides clear goals and measurable progress, helping you stay on track.

---

### 11. Growth Mindset

- **What it is**: This mindset emphasizes the belief that abilities and intelligence can be developed through dedication and hard work.

- **How to apply**: When facing challenges or struggling with a difficult programming concept, remind yourself that it’s a learning opportunity, and success comes from effort and persistence, not innate ability.

- **Benefit**: Keeps you motivated and helps overcome setbacks, particularly in difficult learning situations.

---

### 12. The "One Thing" Framework

- **What it is**: A productivity strategy that suggests focusing on the single most important task that will make the biggest impact.

- **How to apply**: When learning a new framework or programming language, choose one thing to focus on at a time (e.g., mastering async programming or learning a key library) rather than scattering your attention across multiple areas.

- **Benefit**: Deepens mastery by concentrating your effort on what matters most at that moment.

By combining some of these strategies, you can structure your learning in a way that helps you absorb and retain more programming knowledge while avoiding overwhelm. The key is to find what works best for you and adapt it as needed.

---

## Books

![Developer Career Masterplan by Heather VanCura, Bruno Souza](https://learning.oreilly.com/library/cover/9781801818704/750w/){ width="300" }

---

- [Developer Career Masterplan by Heather VanCura, Bruno Souza](https://www.oreilly.com/library/view/developer-career-masterplan/9781801818704/)
